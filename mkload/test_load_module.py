import random
import sys
import cocotb
import logging as log
from cocotb.decorators import coroutine
from cocotb.triggers import Timer, RisingEdge
from cocotb_bus.monitors import BusMonitor
from cocotb_bus.drivers import BusDriver
from cocotb.binary import BinaryValue
from cocotb.regression import TestFactory
from cocotb_bus.scoreboard import Scoreboard
from cocotb.result import TestFailure
from cocotb.clock import Clock
from load_module_model import axi_read_request_gen
from cocotb_coverage.coverage import *


# from load_module_model import sram_write_request_gen

# Load module parameters
#
# Load instruction -> (AXI request -> AXI response -> SRAM_request) -> Load complete

bank_bits = 4
index_bits = 6
valid_bits = 4
num_buffers_bits = 2
data_width = 128

ibuf_start  = 0x01000000
ibuf_end    = 0x01ffffff
wbuf_start  = 0x02000000
wbuf_end    = 0x02ffffff
obuf1_start = 0x03000000
obuf1_end   = 0x037fffff
obuf2_start = 0x03800000
obuf2_end   = 0x03ffffff

##Current load module parameters
#Ifc_load_Module#(`DRAM_ADDR_WIDTH, Datawidth, `SRAM_ADDR_WIDTH, 
#                                    `WBUF_INDEX, `WBUF_Bankbits, `INWIDTH,
#                                    `IBUF_INDEX, `IBUF_Bankbits, `INWIDTH,
#                                    `OBUF_INDEX, `OBUF_Bankbits, `OUTWIDTH, 
#                                    Max_index, Max_bank, Max_data, Max_words, 20)
##

Load_parameters_Coverage = coverage_section (
  CoverPoint("top.inp_x_size", vname="inp_x_size", bins = [1,2,4,8,16,32,64,128]),
  CoverPoint("top.inp_y_size", vname="inp_y_size", bins = [1,2,4,8,16,32,64,128]),
  CoverPoint("top.inp_z_size", vname="inp_z_size", bins = [1,2,4,8,16]),
  CoverPoint("top.inp_y_stride", vname="inp_y_stride", bins = [1,2,4,8,16,32,64,128]),
  CoverPoint("top.inp_z_stride", vname="inp_z_stride", bins = [1,2,4,8,16,32,64,128]),
  CoverPoint("top.inp_bitwidth", vname="inp_bitwidth", bins = [0,1]),
  CoverCross("top.cross_cover", items = ["top.inp_x_size", "top.inp_y_size", "top.inp_z_size", "top.inp_y_stride", "top.inp_z_stride", "top.inp_bitwidth"])
)

class Load_instruction(BusDriver):

    _signals = [
        'EN_subifc_put_loadparams_put',
        'subifc_put_loadparams_put',
    ]

    def __init__(self, dut):
        BusDriver.__init__(self, dut, None, dut.CLK)


class Load_instruction_transaction(object):

    def __init__(self, tb,
                 EN_subifc_put_loadparams_put=0,
                 subifc_put_loadparams_put=0
                 ):
        self.EN_subifc_put_loadparams_put = BinaryValue(
            EN_subifc_put_loadparams_put, tb.EN_width, False)
        self.subifc_put_loadparams_put = BinaryValue(
            subifc_put_loadparams_put, tb.load_instruction_width, False)


class Load_instruction_monitor(BusMonitor):

    _signals = [
        'EN_subifc_put_loadparams_put',
        'subifc_put_loadparams_put',
    ]

    def __init__(self, dut, callback=None, event=None):
        BusMonitor.__init__(self, dut, None,
                            dut.CLK, dut.RST_N,
                            callback=callback,
                            event=event)
        self.name = "in"

    @coroutine
    def _monitor_recv(self):
        EN_inp_edge = RisingEdge(self.bus.EN_subifc_put_loadparams_put)
        while True:
            yield EN_inp_edge
            if self.bus.EN_subifc_put_loadparams_put.value.integer == 1:
                print('[IN_MON] {0:25} : {1}'.format(
                    'subifc_put_loadparams_put', self.bus.subifc_put_loadparams_put.value.integer))
                vec = (
                    self.bus.EN_subifc_put_loadparams_put.value.integer,
                    self.bus.subifc_put_loadparams_put.value.integer
                )
                self._recv(vec)
            yield RisingEdge(self.clock)


class AXI_master_read_response(BusDriver):

    _signals = [
        # 1 # Read address ready. This signal indicates that the slave is ready to accept an address and associated control signals.
        'master_ARREADY',
        # 1 # Read valid. This signal indicates that the channel is signaling the required read data.
        'master_RVALID',
        # 2 # Read response. This signal indicates the status of the read transfer.
        'master_RRESP',
        'master_RDATA',     # 128 # Read data
        # 1 # Read last. This signal indicates the last transfer in a read burst.
        'master_RLAST',
        # 4 # Read ID tag. This signal is the identification tag for the read data group of signals generated by the slave.
        'master_RID',
    ]

    def __init__(self, dut):
        BusDriver.__init__(self, dut, None, dut.CLK)


class AXI_master_read_response_transaction(object):

    def __init__(self, tb,
                 master_ARREADY=1,
                 master_RVALID=0,
                 master_RRESP=0,
                 master_RDATA=0,
                 master_RLAST=0,
                 master_RID=0
                 ):
        self.master_ARREADY = BinaryValue(
            master_ARREADY, tb.arready_width, False)
        self.master_RVALID = BinaryValue(master_RVALID, tb.rvalid_width, False)
        self.master_RRESP = BinaryValue(master_RRESP, tb.rresp_width, False)
        self.master_RDATA = BinaryValue(master_RDATA, tb.rdata_width, False)
        self.master_RLAST = BinaryValue(master_RLAST, tb.rlast_width, False)
        self.master_RID = BinaryValue(master_RID, tb.rid_width, False)


class AXI_master_read_response_monitor(BusMonitor):

    _signals = [
        'master_ARREADY',
        'master_RVALID',
        'master_RRESP',
        'master_RDATA',
        'master_RLAST',
        'master_RID',
    ]

    def __init__(self, dut, callback=None, event=None):
        BusMonitor.__init__(self, dut, None,
                            dut.CLK, dut.RST_N,
                            callback=callback,
                            event=event)
        self.name = "in"

    @coroutine
    def _monitor_recv(self):
        while True:
            read_valid_edge = RisingEdge(self.bus.master_RVALID)
            #read_valid_edge = RisingEdge(self.clock)
            yield read_valid_edge
            if self.bus.master_RVALID.value.integer == 1:
                print('[IN_MON] {0:25} : {1}'.format(
                    'master_ARREADY', self.bus.master_ARREADY.value.integer))
                print('[IN_MON] {0:25} : {1}'.format(
                    'master_RVALID', self.bus.master_RVALID.value.integer))
                print('[IN_MON] {0:25} : {1}'.format(
                    'master_RRESP', self.bus.master_RRESP.value.integer))
                print('[IN_MON] {0:25} : {1}'.format(
                    'master_RDATA', self.bus.master_RDATA.value.integer))
                print('[IN_MON] {0:25} : {1}'.format(
                    'master_RLAST', self.bus.master_RLAST.value.integer))
                print('[IN_MON] {0:25} : {1}'.format(
                    'master_RID', self.bus.master_RID.value.integer))

                vec = (
                    self.bus.master_ARREADY.value.integer,
                    self.bus.master_RVALID.value.integer,
                    self.bus.master_RRESP.value.integer,
                    self.bus.master_RDATA.value.integer,
                    self.bus.master_RLAST.value.integer,
                    self.bus.master_RID.value.integer
                )
                self._recv(vec)
            yield RisingEdge(self.clock)

# class AXI_Master_request():
# class SRAM_request()
# class Load_complete()


class AXI_master_read_request_transaction(object):
    """ Transaction to be expected / received by OutputMonitor"""

    def __init__(self, tb=None,
                 #
                 master_ARVALID=1,   # 1  # Read address valid. This signal indicates that the channel is signaling valid read address and control information
                 # 32 # Read address. The read address gives the address of the first transfer in a read burst transaction.
                 master_ARADDR=0,
                 # 3  # Protection type. This signal indicates the privilege and security level of the transaction, and whether the transaction is a data access or an instruction access.
                 master_ARPROT=0,
                 # 8  # Burst length. This signal indicates the exact number of transfers in a burst. This changes between AXI3 and AXI4.
                 master_ARLEN=0,
                 # 3  # Burst size. This signal indicates the size of each transfer in the burst.
                 master_ARSIZE=0,
                 master_ARBURST=0,   # 2  # Burst type. The burst type and the size information determine how the address for each transfer within the burst is calculated
                 # 4  # Read address ID. This signal is the identification tag for the read address group of signals.
                 master_ARID=0,
                 # 1  # Read ready. This signal indicates that the master can accept the read data and response information.
                 master_RREADY=0,
                 ):
        """For expected transactions, value 'None' means don't care.
        tb must be an instance of the Testbench class."""
#
        if master_ARVALID is not None and isinstance(master_ARVALID, int):
            master_ARVALID = BinaryValue(
                master_ARVALID, tb.arvalid_width, False)
        if master_ARADDR is not None and isinstance(master_ARADDR, int):
            master_ARADDR = BinaryValue(master_ARADDR, tb.araddr_width, False)
        if master_ARPROT is not None and isinstance(master_ARPROT, int):
            master_ARPROT = BinaryValue(master_ARPROT, tb.arprot_width, False)
        if master_ARLEN is not None and isinstance(master_ARLEN, int):
            master_ARLEN = BinaryValue(master_ARLEN, tb.arlen_width, False)
        if master_ARSIZE is not None and isinstance(master_ARSIZE, int):
            master_ARSIZE = BinaryValue(master_ARSIZE, tb.arsize_width, False)
        if master_ARBURST is not None and isinstance(master_ARBURST, int):
            master_ARBURST = BinaryValue(
                master_ARBURST, tb.arburst_width, False)
        if master_ARID is not None and isinstance(master_ARID, int):
            master_ARID = BinaryValue(master_ARID, tb.arid_width, False)
        if master_RREADY is not None and isinstance(master_RREADY, int):
            master_RREADY = BinaryValue(master_RREADY, tb.rready_width, False)
#
        self.value = (
            master_ARVALID,
            master_ARADDR,
            master_ARPROT,
            master_ARLEN,
            master_ARSIZE,
            master_ARBURST,
            master_ARID,
            master_RREADY
        )


class AXI_master_read_request_monitor(BusMonitor):
    """Observes signals of DUT"""
    _signals = [
        #
        'master_ARVALID',
        'master_ARADDR',
        'master_ARPROT',
        'master_ARLEN',
        'master_ARSIZE',
        'master_ARBURST',
        'master_ARID',
        'master_RREADY',
        'master_ARREADY',
    ]

    def __init__(self, dut, tb, callback=None, event=None):
        BusMonitor.__init__(self, dut, None, dut.CLK, dut.RST_N,
                            callback=callback, event=event)
        self.name = "out"
        self.tb = tb

    @coroutine
    def _monitor_recv(self):
        outp_ready_edge = RisingEdge(self.clock)
        while True:
            yield outp_ready_edge
            if self.bus.master_ARVALID.value.integer == 1 and self.bus.master_ARREADY.value.integer == 1:
                print('[DUT_MON] {0:<25} : {1}'.format(
                    'master_RREADY ', hex(self.bus.master_RREADY.value)))
                print('[DUT_MON] {0:<25} : {1}'.format(
                    'master_ARVALID ', hex(self.bus.master_ARVALID.value)))
                print('[DUT_MON] {0:<25} : {1}'.format(
                    'master_ARADDR ', hex(self.bus.master_ARADDR.value)))
                print('[DUT_MON] {0:<25} : {1}'.format(
                    'master_ARPROT ', hex(self.bus.master_ARPROT.value)))
                print('[DUT_MON] {0:<25} : {1}'.format(
                    'master_ARLEN ', hex(self.bus.master_ARLEN.value)))
                print('[DUT_MON] {0:<25} : {1}'.format(
                    'master_ARSIZE ', hex(self.bus.master_ARSIZE.value)))
                print('[DUT_MON] {0:<25} : {1}'.format(
                    'master_ARBURST ', hex(self.bus.master_ARBURST.value)))
                print('[DUT_MON] {0:<25} : {1}'.format(
                    'master_ARID ', hex(self.bus.master_ARID.value)))

                
                vec = (
                    self.bus.master_RREADY.value.integer,
                    self.bus.master_ARVALID.value.integer,
                    self.bus.master_ARADDR.value.integer,
                    self.bus.master_ARPROT.value.integer,
                    self.bus.master_ARLEN.value.integer,
                    self.bus.master_ARSIZE.value.integer,
                    self.bus.master_ARBURST.value.integer,
                    self.bus.master_ARID.value.integer
                )
                self._recv(vec)
            #yield RisingEdge(self.clock)

class SRAM_read_transaction(object):
    """ Transaction to be expected / received by OutputMonitor"""

    def __init__(self, tb=None,
                 #
                 RDY_write_data=0,
                 write_data=0,
                 ):
#
        if RDY_write_data is not None and isinstance(RDY_write_data, int):
            RDY_write_data = BinaryValue(
                RDY_write_data, tb.RDY_width, False)
        if write_data is not None and isinstance(write_data, int):
            write_data = BinaryValue(
                write_data, tb.sram_write_data_width, False)
#
        self.value = (
            RDY_write_data,
            write_data
        )


class SRAM_read_monitor(BusMonitor):
    """Observes signals of DUT"""
    _signals = [
        #
        'RDY_write_data',
        'write_data',
    ]

    def __init__(self, dut, tb, callback=None, event=None):
        BusMonitor.__init__(self, dut, None, dut.CLK, dut.RST_N,
                            callback=callback, event=event)
        self.name = "out"
        self.tb = tb

    @coroutine
    def _monitor_recv(self):
        outp_ready_edge = RisingEdge(self.bus.RDY_write_data)
        while True:
            yield outp_ready_edge
            if self.bus.RDY_write_data.value.integer == 1:
                print('[DUT_MON] {0:<25} : {1}'.format(
                    'RDY_write_data ', hex(self.bus.RDY_write_data.value)))
                print('[DUT_MON] {0:<25} : {1}'.format(
                    'write_data ', hex(self.bus.write_data.value)))
                
                vec = (
                    self.bus.RDY_write_data.value.integer,
                    self.bus.write_data.value.integer
                )
                self._recv(vec)
            yield RisingEdge(self.clock)


class DUTScoreboard(Scoreboard):
    def compare(self, exp_count, exp_addr,exp_arlen, got_count, got_addr, got_arlen, 
                exp_buffer, exp_index, exp_bank, exp_valid, exp_error, 
                got_buffer, got_index, got_bank, got_valid,log, **_):
        print("Entered Scoreboard")
        print(exp_count)
        print(got_count)
        print(exp_addr)
        print(got_addr)
        print(exp_buffer)
        print(got_buffer)
        print(exp_index)
        print(got_index)
        print(exp_bank)
        print(got_bank)
        print(exp_valid)
        print(got_valid)
        print(exp_error)
        if(exp_count == got_count):
            if(exp_arlen == got_arlen):
                for n in range(exp_count):
                    if(exp_addr[n] == got_addr[n]):
                        print("DRAM Address matched : ",hex(exp_addr[n]),n)
                    else:
                        print("DRAM Address mismatch : ",hex(exp_addr[n]),hex(got_addr[n]),n)
            else:
                print("ARLEN mismatch ",exp_arlen,got_arlen)
        else:
            print("mismatch in number of AXI requests ", exp_count, got_count)


        if(exp_error):
            print("SRAM address mismatch doesn't belong to any buffer")
        if(exp_buffer == got_buffer):
            print("SRAM Buffer matched : ",hex(exp_buffer))
        else:
            print("SRAM Buffer mismatch ", hex(exp_buffer), hex(got_buffer))
        for n in range(exp_count*(exp_arlen+1)):
            if(exp_bank[n] == got_bank[n]):
                print("SRAM Bank matched : ",hex(exp_bank[n]))
            else:
                print("SRAM Bank mismatch : ",hex(exp_bank[n]), hex(got_bank[n]))
            if(exp_index[n] == got_index[n]):
                print("SRAM Index matched : ",hex(exp_index[n]))
            else:
                print("SRAM Index mismatch : ",hex(exp_index[n]), hex(got_index[n]))
            if(exp_valid[n] == got_valid[n]):
                print("SRAM Valid matched : ",hex(exp_valid[n]))
            else:
                print("SRAM Valid mismatch : ",hex(exp_valid[n]), hex(got_valid[n]))


class TestBench(object):
    """Verification Test Bench"""

    def __init__(self, dut):
        self.dut = dut
        self.stopped = False

        """Signal length"""
        self.EN_width = 1
        self.RDY_width = 1
        self.load_instruction_width = 120
        self.arready_width = 1
        self.rvalid_width = 1
        self.rresp_width = 2
        self.rdata_width = 128
        self.rlast_width = 1
        self.rid_width = 4

        self.arvalid_width = 1
        self.araddr_width = 32
        self.arprot_width = 3
        self.arlen_width = 8
        self.arsize_width = 3
        self.arburst_width = 2
        self.arid_width = 4
        self.rready_width = 1

        self.in_width = 8
        self.out_width = 32

        self.sram_write_data_width = 144

        self.load_instruction_drv = Load_instruction(dut)
        self.load_instruction_mon = Load_instruction_monitor(
            dut, callback=self.dram_model)
        self.axi_master_read_response_drv = AXI_master_read_response(dut)
        self.axi_master_read_response_mon = AXI_master_read_response_monitor(
            dut)

        init_val = AXI_master_read_request_transaction(self)
        self.mon = AXI_master_read_request_monitor(dut, self, callback = self.count_axi_read_req)

        self.expected_dram_req_count = 0
        self.axi_dram_read_req_count = 0

        self.expected_dram_address = []
        self.axi_dram_read_req_addr = []

        self.expected_arlen = 0
        self.axi_dram_read_req_arlen = 0

        sram_init_val = SRAM_read_transaction(self)
        self.sram_mon = SRAM_read_monitor(dut,self, callback = self.count_sram_read_req)

        self.expected_sram_buffer = 0
        self.sram_req_buffer = 0

        self.expected_sram_index = []
        self.sram_req_index = []

        self.expected_sram_bank = []
        self.sram_req_bank = []

        self.expected_sram_valid = []
        self.sram_req_valid = []

        self.error_from_model = False
        
        self.scoreboard = DUTScoreboard(dut)
        # self.scoreboard.add_interface(self.mon, self.expected_output)


    def dram_model(self, transaction):
        (
            EN_subifc_put_loadparams_put,
            subifc_put_loadparams_put,
        ) = transaction

        print(hex(subifc_put_loadparams_put))
        subifc_put_loadparams_put = int(
            (bin(subifc_put_loadparams_put)[2:])[::-1], 2)
        print(hex(subifc_put_loadparams_put))
        model_bitwidth = int((bin(subifc_put_loadparams_put)[22:23])[::-1], 2)
        model_is_reset = int((bin(subifc_put_loadparams_put)[23:24])[::-1], 2)
        model_y_stride = int((bin(subifc_put_loadparams_put)[24:32])[::-1], 2)
        model_z_stride = int((bin(subifc_put_loadparams_put)[32:40])[::-1], 2)
        model_z_size = int((bin(subifc_put_loadparams_put)[40:48])[::-1], 2)
        model_y_size = int((bin(subifc_put_loadparams_put)[48:56])[::-1], 2)
        model_x_size = int((bin(subifc_put_loadparams_put)[56:64])[::-1], 2)
        model_sram_addr = int((bin(subifc_put_loadparams_put)[64:90])[::-1], 2)
        model_dram_addr = int((bin(subifc_put_loadparams_put)[90:])[::-1], 2)

        print("MODEL")
        print(model_dram_addr, model_sram_addr, model_x_size, model_y_size,
              model_z_size, model_y_stride, model_z_stride, model_is_reset, model_bitwidth)
        if(model_bitwidth == 1):
            model_bitwidth = int(self.in_width/8)
        else:
            model_bitwidth = int(self.out_width/8)

        expected_address, expected_count, expected_burst_len,expected_sram_buffer, expected_sram_indices, expected_sram_bank, expected_sram_valid, error = axi_read_request_gen(model_dram_addr, model_sram_addr, model_x_size, model_y_size, model_z_size, model_z_stride, model_y_stride,
                                                                model_bitwidth)
        print("FROM MODEL expected requests : ",expected_count)
        print("From MODEL expected addresses : ",expected_address)
        print("FROM MODEL expected arlen : ",expected_burst_len)
        self.expected_dram_address = expected_address
        self.expected_dram_req_count = expected_count
        self.expected_arlen = expected_burst_len
        self.expected_sram_buffer = expected_sram_buffer
        self.expected_sram_index = expected_sram_indices
        self.expected_sram_bank = expected_sram_bank
        self.expected_sram_valid = expected_sram_valid
        self.error_from_model = error

    def count_axi_read_req(self, transaction):
        (
            master_RREADY,
            master_ARVALID,
            master_ARADDR,
            master_ARPROT,
            master_ARLEN,
            master_ARSIZE,
            master_ARBURST,
            master_ARID,
        )=transaction

        self.axi_dram_read_req_count = self.axi_dram_read_req_count + 1
        self.axi_dram_read_req_addr.append(master_ARADDR)
        self.axi_dram_read_req_arlen = master_ARLEN
        print("From count_axi_read_req count and addr")
        print(self.axi_dram_read_req_count)
        print(hex(master_ARADDR))
        print(master_ARLEN)

    def count_sram_read_req(self,transaction):
        (
            RDY_write_data,
            write_data,
        )=transaction

        write_data = write_data | 1 << 145
        sram_buffer = int((bin(write_data)[3:5]),2)
        sram_index = int((bin(write_data)[5:11]),2)
        sram_bank = int((bin(write_data)[11:15]),2)
        sram_valid = int((bin(write_data)[143:]),2)
        self.sram_req_valid.append(sram_valid)
        self.sram_req_bank.append(sram_bank)
        self.sram_req_index.append(sram_index)
        self.sram_req_buffer = sram_buffer
        print("SRAM request from DUT : ",hex(write_data),hex(sram_buffer),hex(sram_index),hex(sram_bank),hex(sram_valid))

    def send_output_to_scoreboard(self):
        print("output comparison")
        self.scoreboard.compare(self.expected_dram_req_count,self.expected_dram_address,self.expected_arlen,
                                self.axi_dram_read_req_count,self.axi_dram_read_req_addr,self.axi_dram_read_req_arlen,
                                self.expected_sram_buffer,self.expected_sram_index,self.expected_sram_bank,self.expected_sram_valid, self.error_from_model,
                                self.sram_req_buffer,self.sram_req_index,self.sram_req_bank,self.sram_req_valid,
                                self.scoreboard.log)
        self.expected_dram_address.clear
        self.axi_dram_read_req_addr = [] ## Not able to clear the contents by .clear ??
        self.expected_dram_req_count = 0
        self.axi_dram_read_req_count = 0
        self.expected_arlen = 0
        self.axi_dram_read_req_arlen = 0
        self.expected_sram_buffer = 0
        self.sram_req_buffer = 0
        self.expected_sram_index.clear
        self.sram_req_index = []
        self.expected_sram_bank.clear
        self.sram_req_bank = []
        self.expected_sram_valid.clear
        self.sram_req_valid = []
        self.error_from_model = False

    def stop(self):
        self.stopped = True


def axi_read_response_from_tb(tb, arready, rvalid, rresp, rdata, rlast, rid):
    master_ARREADY = arready
    master_RVALID = rvalid
    master_RRESP = rresp
    master_RDATA = rdata
    master_RLAST = rlast
    master_RID = rid
    yield AXI_master_read_response_transaction(tb,
                                               master_ARREADY,
                                               master_RVALID,
                                               master_RRESP,
                                               master_RDATA,
                                               master_RLAST,
                                               master_RID)



@cocotb.coroutine
def clock_gen(signal):
    while True:
        signal.value <= 0
        yield Timer(1)
        signal.value <= 1
        yield Timer(1)


@cocotb.test()
def run_test(dut):
    log = cocotb.logging.getLogger("cocotb.test") #logger instance
    cocotb.fork(clock_gen(dut.CLK))
    tb = TestBench(dut)
    dut.RST_N.value <= 0
    yield Timer(2)
    dut.RST_N.value <= 1

    data_width = 128
    in_width = 8
    out_width = 32

    tb.in_width = in_width
    tb.out_width = out_width

    @Load_parameters_Coverage
    @cocotb.coroutine
    def send_load_instruction(inp_dram_address,inp_sram_address,inp_x_size,inp_y_size,inp_z_size,inp_z_stride,inp_y_stride,
                                    inp_is_reset,inp_bitwidth,inp_padding):
        subifc_put_loadparams_put = (inp_padding | inp_bitwidth << 20 | inp_is_reset << 21 |
                                        inp_y_stride << 22 | inp_z_stride << 30 | inp_z_size << 38 |
                                        inp_y_size << 46 | inp_x_size << 54 | inp_sram_address << 62 |
                                        inp_dram_address << 88)
        EN_subifc_put_loadparams_put = 1
        yield tb.load_instruction_drv.send(Load_instruction_transaction(tb,EN_subifc_put_loadparams_put, subifc_put_loadparams_put))
        EN_subifc_put_loadparams_put = 0
        yield tb.load_instruction_drv.send(Load_instruction_transaction(tb,EN_subifc_put_loadparams_put, subifc_put_loadparams_put))

    for n in range(100):
        size_array_1 = [1,2,4,8,16,32,64,128]
        size_array_2 = [1,2,4,8,16]
        #size_array_2 = [16,32,64,128]
        inp_dram_address = 0x80000000   # 32
        buf_array = [1,2,3,4]
        buf_choice = random.choice(buf_array)
        if(buf_choice == 1):
            inp_sram_address = 0x1000000    # 26
            inp_bitwidth = 0x1
        elif(buf_choice == 2):
            inp_sram_address = 0x2000000
            inp_bitwidth = 0x1
        elif(buf_choice == 3):
            inp_sram_address = 0x3000000
            inp_bitwidth = 0x0
        else:
            inp_sram_address = 0x3800000
            inp_bitwidth = 0x0
        inp_x_size = random.choice(size_array_1)               # 8
        inp_y_size = random.choice(size_array_1)               # 8
        inp_z_size = random.choice(size_array_2)               # 8
        inp_z_stride = random.choice(size_array_1)             # 8
        inp_y_stride = random.choice(size_array_1)             # 8
        inp_is_reset = 0x1                                   # 1
        #inp_x_size = 2            # 8
        #inp_y_size = 4            # 8
        #inp_z_size = 32            # 8
        #inp_z_stride = 128            # 8
        #inp_y_stride =  32           # 8
        #inp_bitwidth = 0x1
        inp_padding = 0x80001           # 20

        print("Input to DUT ",n)
        print("dram address: ",hex(inp_dram_address))
        print("sram address: ",hex(inp_sram_address))
        print("x size: ",inp_x_size)
        print("y size: ",inp_y_size)
        print("z size: ",inp_z_size)
        print("y stride: ",inp_y_stride)
        print("z stride: ",inp_z_stride)
        print("is reset: ",inp_is_reset)
        print("bitwidth: ",inp_bitwidth)
        print("padding: ",inp_padding)

        yield send_load_instruction(inp_dram_address,inp_sram_address,inp_x_size,inp_y_size,inp_z_size,inp_z_stride,inp_y_stride,
                                    inp_is_reset,inp_bitwidth,inp_padding)

        if inp_bitwidth == 1:
            inp_bitwidth = in_width
        else:
            inp_bitwidth = out_width

        print("inp_bitwidth")
        print(inp_bitwidth)

        num_axi_res = int(inp_z_size * inp_bitwidth / data_width)
        print("Num AXI res per axi req : ", num_axi_res)
        i = 0
        for delay in range(10):
            yield RisingEdge(dut.CLK)
        while(dut.master_ARVALID == 1):
            axi_response = axi_read_response_from_tb(tb, 1, 0, 0, 0, 0, 2)
            print("Sending AXI ARVALID 1 ")
            for a in axi_response:
                yield tb.axi_master_read_response_drv.send(a)
            print("Sent AXI ARVALID")
            axi_response = axi_read_response_from_tb(tb, 0, 0, 0, 0, 0, 2)
            print("Sending AXI ARVALID 0 ")
            for a in axi_response:
                yield tb.axi_master_read_response_drv.send(a)
            print("Sent AXI ARVALID ")

            for t in range(num_axi_res-1):
                if(dut.master_RREADY != 1):
                    yield RisingEdge(dut.master_RREADY)
                axi_response = axi_read_response_from_tb(tb, 0, 0, 0, (t+1) << 127, 0, 2)
                print("Sending AXI response : ",i,t)
                for a in axi_response:
                    yield tb.axi_master_read_response_drv.send(a)
                print("Sent AXI response ")
                axi_response = axi_read_response_from_tb(tb, 0, 1, 0, (t+1) << 127, 0, 2)
                print("Sending AXI RVALID : ",i,t)
                for a in axi_response:
                    yield tb.axi_master_read_response_drv.send(a)
                print("Sent AXI RVALID ")

            if(dut.master_RREADY != 1):
                yield RisingEdge(dut.master_RREADY)
            axi_response = axi_read_response_from_tb(tb, 0, 0, 0, (num_axi_res) << 127, 1, 2)
            print("Sending AXI Last response : ",i,num_axi_res-1)
            for a in axi_response:
                yield tb.axi_master_read_response_drv.send(a)
            print("Sent AXI last response")
            axi_response = axi_read_response_from_tb(tb, 0, 1, 0, (num_axi_res) << 127, 1, 2)
            print("Sending AXI last RVALID : ",i,num_axi_res-1)
            for a in axi_response:
                yield tb.axi_master_read_response_drv.send(a)
            print("Sent AXI RVALID for last response ")
            i = i + 1
        axi_response = axi_read_response_from_tb(tb, 0, 0, 0, 0, 0, 2)
        print("End of AXI Request - Sending AXI RVALID low ")
        for a in axi_response:
            yield tb.axi_master_read_response_drv.send(a)
        print("Sent AXI RVALID 0 ")

        yield RisingEdge(dut.RDY_subifc_send_loadfinish_get)

        tb.send_output_to_scoreboard()

    tb.stop()
    for s in range(10):
        yield RisingEdge(dut.CLK)

    coverage_db.export_to_xml(filename="coverage_load_params.xml")
    coverage_db.export_to_yaml(filename="coverage_load_params.yml")
