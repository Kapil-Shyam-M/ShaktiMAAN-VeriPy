//
// Generated by Bluespec Compiler, version 2021.12.1 (build fd501401)
//
// On Thu Jan 20 13:02:22 IST 2022
//
//
// Ports:
// Name                         I/O  size props
// master_AWVALID                 O     1 reg
// master_AWADDR                  O    32 reg
// master_AWPROT                  O     3 reg
// master_AWLEN                   O     8 reg
// master_AWSIZE                  O     3 reg
// master_AWBURST                 O     2 reg
// master_AWID                    O     4 reg
// master_WVALID                  O     1 reg
// master_WDATA                   O   128 reg
// master_WSTRB                   O    16 reg
// master_WLAST                   O     1 reg
// master_WID                     O     4 reg
// master_BREADY                  O     1 reg
// master_ARVALID                 O     1 reg
// master_ARADDR                  O    32 reg
// master_ARPROT                  O     3 reg
// master_ARLEN                   O     8 reg
// master_ARSIZE                  O     3 reg
// master_ARBURST                 O     2 reg
// master_ARID                    O     4 reg
// master_RREADY                  O     1 reg
// RDY_subifc_put_loadparams_put  O     1
// subifc_send_loadfinish_get     O     1 const
// RDY_subifc_send_loadfinish_get  O     1
// write_data                     O   149
// RDY_write_data                 O     1
// send_interrupt                 O     1 reg
// RDY_send_interrupt             O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// master_AWREADY                 I     1
// master_WREADY                  I     1
// master_BVALID                  I     1
// master_BRESP                   I     2 reg
// master_BID                     I     4 reg
// master_ARREADY                 I     1
// master_RVALID                  I     1
// master_RRESP                   I     2 reg
// master_RDATA                   I   128 reg
// master_RLAST                   I     1 reg
// master_RID                     I     4 reg
// subifc_put_loadparams_put      I   120
// EN_subifc_put_loadparams_put   I     1
// EN_subifc_send_loadfinish_get  I     1
// EN_write_data                  I     1 unused
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkload(CLK,
	      RST_N,

	      master_AWVALID,

	      master_AWADDR,

	      master_AWPROT,

	      master_AWLEN,

	      master_AWSIZE,

	      master_AWBURST,

	      master_AWID,

	      master_AWREADY,

	      master_WVALID,

	      master_WDATA,

	      master_WSTRB,

	      master_WLAST,

	      master_WID,

	      master_WREADY,

	      master_BVALID,
	      master_BRESP,
	      master_BID,

	      master_BREADY,

	      master_ARVALID,

	      master_ARADDR,

	      master_ARPROT,

	      master_ARLEN,

	      master_ARSIZE,

	      master_ARBURST,

	      master_ARID,

	      master_ARREADY,

	      master_RVALID,
	      master_RRESP,
	      master_RDATA,
	      master_RLAST,
	      master_RID,

	      master_RREADY,

	      subifc_put_loadparams_put,
	      EN_subifc_put_loadparams_put,
	      RDY_subifc_put_loadparams_put,

	      EN_subifc_send_loadfinish_get,
	      subifc_send_loadfinish_get,
	      RDY_subifc_send_loadfinish_get,

	      EN_write_data,
	      write_data,
	      RDY_write_data,

	      send_interrupt,
	      RDY_send_interrupt);
  input  CLK;
  input  RST_N;

  // value method master_m_awvalid
  output master_AWVALID;

  // value method master_m_awaddr
  output [31 : 0] master_AWADDR;

  // value method master_m_awuser

  // value method master_m_awprot
  output [2 : 0] master_AWPROT;

  // value method master_m_awlen
  output [7 : 0] master_AWLEN;

  // value method master_m_awsize
  output [2 : 0] master_AWSIZE;

  // value method master_m_awburst
  output [1 : 0] master_AWBURST;

  // value method master_m_awid
  output [3 : 0] master_AWID;

  // action method master_m_awready
  input  master_AWREADY;

  // value method master_m_wvalid
  output master_WVALID;

  // value method master_m_wdata
  output [127 : 0] master_WDATA;

  // value method master_m_wstrb
  output [15 : 0] master_WSTRB;

  // value method master_m_wlast
  output master_WLAST;

  // value method master_m_wid
  output [3 : 0] master_WID;

  // action method master_m_wready
  input  master_WREADY;

  // action method master_m_bvalid
  input  master_BVALID;
  input  [1 : 0] master_BRESP;
  input  [3 : 0] master_BID;

  // value method master_m_bready
  output master_BREADY;

  // value method master_m_arvalid
  output master_ARVALID;

  // value method master_m_araddr
  output [31 : 0] master_ARADDR;

  // value method master_m_aruser

  // value method master_m_arprot
  output [2 : 0] master_ARPROT;

  // value method master_m_arlen
  output [7 : 0] master_ARLEN;

  // value method master_m_arsize
  output [2 : 0] master_ARSIZE;

  // value method master_m_arburst
  output [1 : 0] master_ARBURST;

  // value method master_m_arid
  output [3 : 0] master_ARID;

  // action method master_m_arready
  input  master_ARREADY;

  // action method master_m_rvalid
  input  master_RVALID;
  input  [1 : 0] master_RRESP;
  input  [127 : 0] master_RDATA;
  input  master_RLAST;
  input  [3 : 0] master_RID;

  // value method master_m_rready
  output master_RREADY;

  // action method subifc_put_loadparams_put
  input  [119 : 0] subifc_put_loadparams_put;
  input  EN_subifc_put_loadparams_put;
  output RDY_subifc_put_loadparams_put;

  // actionvalue method subifc_send_loadfinish_get
  input  EN_subifc_send_loadfinish_get;
  output subifc_send_loadfinish_get;
  output RDY_subifc_send_loadfinish_get;

  // actionvalue method write_data
  input  EN_write_data;
  output [148 : 0] write_data;
  output RDY_write_data;

  // value method send_interrupt
  output send_interrupt;
  output RDY_send_interrupt;

  // signals for module outputs
  wire [148 : 0] write_data;
  wire [127 : 0] master_WDATA;
  wire [31 : 0] master_ARADDR, master_AWADDR;
  wire [15 : 0] master_WSTRB;
  wire [7 : 0] master_ARLEN, master_AWLEN;
  wire [3 : 0] master_ARID, master_AWID, master_WID;
  wire [2 : 0] master_ARPROT, master_ARSIZE, master_AWPROT, master_AWSIZE;
  wire [1 : 0] master_ARBURST, master_AWBURST;
  wire RDY_send_interrupt,
       RDY_subifc_put_loadparams_put,
       RDY_subifc_send_loadfinish_get,
       RDY_write_data,
       master_ARVALID,
       master_AWVALID,
       master_BREADY,
       master_RREADY,
       master_WLAST,
       master_WVALID,
       send_interrupt,
       subifc_send_loadfinish_get;

  // inlined wires
  wire inst1_wr_buffer_req$whas;

  // register inst1_rg_burst
  reg inst1_rg_burst;
  wire inst1_rg_burst$D_IN, inst1_rg_burst$EN;

  // register inst1_rg_burst_addr
  reg [26 : 0] inst1_rg_burst_addr;
  wire [26 : 0] inst1_rg_burst_addr$D_IN;
  wire inst1_rg_burst_addr$EN;

  // register inst1_rg_burst_len
  reg [7 : 0] inst1_rg_burst_len;
  wire [7 : 0] inst1_rg_burst_len$D_IN;
  wire inst1_rg_burst_len$EN;

  // register inst1_rg_dram_addr
  reg [31 : 0] inst1_rg_dram_addr;
  wire [31 : 0] inst1_rg_dram_addr$D_IN;
  wire inst1_rg_dram_addr$EN;

  // register inst1_rg_finish_load
  reg inst1_rg_finish_load;
  wire inst1_rg_finish_load$D_IN, inst1_rg_finish_load$EN;

  // register inst1_rg_interrupt
  reg inst1_rg_interrupt;
  wire inst1_rg_interrupt$D_IN, inst1_rg_interrupt$EN;

  // register inst1_rg_load_requests
  reg inst1_rg_load_requests;
  wire inst1_rg_load_requests$D_IN, inst1_rg_load_requests$EN;

  // register inst1_rg_params
  reg [120 : 0] inst1_rg_params;
  wire [120 : 0] inst1_rg_params$D_IN;
  wire inst1_rg_params$EN;

  // register inst1_rg_sram_addr
  reg [25 : 0] inst1_rg_sram_addr;
  wire [25 : 0] inst1_rg_sram_addr$D_IN;
  wire inst1_rg_sram_addr$EN;

  // register inst1_rg_x_cntr
  reg [7 : 0] inst1_rg_x_cntr;
  wire [7 : 0] inst1_rg_x_cntr$D_IN;
  wire inst1_rg_x_cntr$EN;

  // register inst1_rg_xyz_size
  reg [25 : 0] inst1_rg_xyz_size;
  wire [25 : 0] inst1_rg_xyz_size$D_IN;
  wire inst1_rg_xyz_size$EN;

  // register inst1_rg_y_cntr
  reg [7 : 0] inst1_rg_y_cntr;
  wire [7 : 0] inst1_rg_y_cntr$D_IN;
  wire inst1_rg_y_cntr$EN;

  // register inst1_rg_z_cntr
  reg [7 : 0] inst1_rg_z_cntr;
  wire [7 : 0] inst1_rg_z_cntr$D_IN;
  wire inst1_rg_z_cntr$EN;

  // register inst1_rg_zy_size
  reg [25 : 0] inst1_rg_zy_size;
  wire [25 : 0] inst1_rg_zy_size$D_IN;
  wire inst1_rg_zy_size$EN;

  // ports of submodule inst1_ff_dest_addr
  wire [25 : 0] inst1_ff_dest_addr$D_IN, inst1_ff_dest_addr$D_OUT;
  wire inst1_ff_dest_addr$CLR,
       inst1_ff_dest_addr$DEQ,
       inst1_ff_dest_addr$EMPTY_N,
       inst1_ff_dest_addr$ENQ,
       inst1_ff_dest_addr$FULL_N;

  // ports of submodule inst1_m_xactor_f_rd_addr
  wire [51 : 0] inst1_m_xactor_f_rd_addr$D_IN, inst1_m_xactor_f_rd_addr$D_OUT;
  wire inst1_m_xactor_f_rd_addr$CLR,
       inst1_m_xactor_f_rd_addr$DEQ,
       inst1_m_xactor_f_rd_addr$EMPTY_N,
       inst1_m_xactor_f_rd_addr$ENQ,
       inst1_m_xactor_f_rd_addr$FULL_N;

  // ports of submodule inst1_m_xactor_f_rd_data
  wire [134 : 0] inst1_m_xactor_f_rd_data$D_IN,
		 inst1_m_xactor_f_rd_data$D_OUT;
  wire inst1_m_xactor_f_rd_data$CLR,
       inst1_m_xactor_f_rd_data$DEQ,
       inst1_m_xactor_f_rd_data$EMPTY_N,
       inst1_m_xactor_f_rd_data$ENQ,
       inst1_m_xactor_f_rd_data$FULL_N;

  // ports of submodule inst1_m_xactor_f_wr_addr
  wire [51 : 0] inst1_m_xactor_f_wr_addr$D_IN, inst1_m_xactor_f_wr_addr$D_OUT;
  wire inst1_m_xactor_f_wr_addr$CLR,
       inst1_m_xactor_f_wr_addr$DEQ,
       inst1_m_xactor_f_wr_addr$EMPTY_N,
       inst1_m_xactor_f_wr_addr$ENQ;

  // ports of submodule inst1_m_xactor_f_wr_data
  wire [148 : 0] inst1_m_xactor_f_wr_data$D_IN,
		 inst1_m_xactor_f_wr_data$D_OUT;
  wire inst1_m_xactor_f_wr_data$CLR,
       inst1_m_xactor_f_wr_data$DEQ,
       inst1_m_xactor_f_wr_data$EMPTY_N,
       inst1_m_xactor_f_wr_data$ENQ;

  // ports of submodule inst1_m_xactor_f_wr_resp
  wire [5 : 0] inst1_m_xactor_f_wr_resp$D_IN;
  wire inst1_m_xactor_f_wr_resp$CLR,
       inst1_m_xactor_f_wr_resp$DEQ,
       inst1_m_xactor_f_wr_resp$ENQ,
       inst1_m_xactor_f_wr_resp$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_inst1_rl_start_dram_Read,
       WILL_FIRE_RL_inst1_rl_start_write;

  // inputs to muxes for submodule ports
  wire [120 : 0] MUX_inst1_rg_params$write_1__VAL_2;
  wire [31 : 0] MUX_inst1_rg_dram_addr$write_1__VAL_1;
  wire [26 : 0] MUX_inst1_rg_burst_addr$write_1__VAL_2;
  wire [25 : 0] MUX_inst1_rg_sram_addr$write_1__VAL_1;
  wire [7 : 0] MUX_inst1_rg_x_cntr$write_1__VAL_1,
	       MUX_inst1_rg_x_cntr$write_1__VAL_2,
	       MUX_inst1_rg_y_cntr$write_1__VAL_1,
	       MUX_inst1_rg_y_cntr$write_1__VAL_2,
	       MUX_inst1_rg_z_cntr$write_1__VAL_2;
  wire MUX_inst1_rg_dram_addr$write_1__SEL_1,
       MUX_inst1_rg_load_requests$write_1__SEL_1,
       MUX_inst1_rg_sram_addr$write_1__SEL_1,
       MUX_inst1_rg_x_cntr$write_1__SEL_1;

  // remaining internal signals
  wire [31 : 0] IF_inst1_rg_params_BIT_20_4_THEN_0_ELSE_2___d25,
		x__h1512,
		x__h1560,
		x__h1647,
		x__h1668,
		y__h1547,
		y__h1667;
  wire [25 : 0] _theResult____h2090, y__h2232;
  wire [10 : 0] lv_shift__h3295;
  wire [7 : 0] shift_op__h3296,
	       x__h1399,
	       x__h1613,
	       x__h2129,
	       x__h2632,
	       x__h2712,
	       y__h2149;
  wire [5 : 0] IF_NOT_IF_inst1_rg_burst_addr_5_BIT_26_6_THEN__ETC___d104;

  // value method master_m_awvalid
  assign master_AWVALID = inst1_m_xactor_f_wr_addr$EMPTY_N ;

  // value method master_m_awaddr
  assign master_AWADDR = inst1_m_xactor_f_wr_addr$D_OUT[51:20] ;

  // value method master_m_awprot
  assign master_AWPROT = inst1_m_xactor_f_wr_addr$D_OUT[19:17] ;

  // value method master_m_awlen
  assign master_AWLEN = inst1_m_xactor_f_wr_addr$D_OUT[16:9] ;

  // value method master_m_awsize
  assign master_AWSIZE = inst1_m_xactor_f_wr_addr$D_OUT[8:6] ;

  // value method master_m_awburst
  assign master_AWBURST = inst1_m_xactor_f_wr_addr$D_OUT[5:4] ;

  // value method master_m_awid
  assign master_AWID = inst1_m_xactor_f_wr_addr$D_OUT[3:0] ;

  // value method master_m_wvalid
  assign master_WVALID = inst1_m_xactor_f_wr_data$EMPTY_N ;

  // value method master_m_wdata
  assign master_WDATA = inst1_m_xactor_f_wr_data$D_OUT[148:21] ;

  // value method master_m_wstrb
  assign master_WSTRB = inst1_m_xactor_f_wr_data$D_OUT[20:5] ;

  // value method master_m_wlast
  assign master_WLAST = inst1_m_xactor_f_wr_data$D_OUT[0] ;

  // value method master_m_wid
  assign master_WID = inst1_m_xactor_f_wr_data$D_OUT[4:1] ;

  // value method master_m_bready
  assign master_BREADY = inst1_m_xactor_f_wr_resp$FULL_N ;

  // value method master_m_arvalid
  assign master_ARVALID = inst1_m_xactor_f_rd_addr$EMPTY_N ;

  // value method master_m_araddr
  assign master_ARADDR = inst1_m_xactor_f_rd_addr$D_OUT[51:20] ;

  // value method master_m_arprot
  assign master_ARPROT = inst1_m_xactor_f_rd_addr$D_OUT[19:17] ;

  // value method master_m_arlen
  assign master_ARLEN = inst1_m_xactor_f_rd_addr$D_OUT[13:6] ;

  // value method master_m_arsize
  assign master_ARSIZE = inst1_m_xactor_f_rd_addr$D_OUT[16:14] ;

  // value method master_m_arburst
  assign master_ARBURST = inst1_m_xactor_f_rd_addr$D_OUT[5:4] ;

  // value method master_m_arid
  assign master_ARID = inst1_m_xactor_f_rd_addr$D_OUT[3:0] ;

  // value method master_m_rready
  assign master_RREADY = inst1_m_xactor_f_rd_data$FULL_N ;

  // action method subifc_put_loadparams_put
  assign RDY_subifc_put_loadparams_put =
	     !inst1_rg_params[120] && inst1_rg_finish_load ;

  // actionvalue method subifc_send_loadfinish_get
  assign subifc_send_loadfinish_get = 1'd1 ;
  assign RDY_subifc_send_loadfinish_get =
	     inst1_rg_params[120] && inst1_rg_finish_load ;

  // actionvalue method write_data
  assign write_data =
	     { (_theResult____h2090 >= 26'h1000000 &&
		_theResult____h2090 <= 26'h1FFFFFF) ?
		 2'd0 :
		 ((_theResult____h2090 >= 26'h2000000 &&
		   _theResult____h2090 <= 26'h2FFFFFF) ?
		    2'd1 :
		    ((_theResult____h2090 <= 26'h37FFFFF) ? 2'd2 : 2'd3)),
	       _theResult____h2090[12:0],
	       inst1_m_xactor_f_rd_data$D_OUT[132:5],
	       IF_NOT_IF_inst1_rg_burst_addr_5_BIT_26_6_THEN__ETC___d104 } ;
  assign RDY_write_data = inst1_rg_params[120] && inst1_wr_buffer_req$whas ;

  // value method send_interrupt
  assign send_interrupt = inst1_rg_interrupt ;
  assign RDY_send_interrupt = 1'd1 ;

  // submodule inst1_ff_dest_addr
  SizedFIFO #(.p1width(32'd26),
	      .p2depth(32'd3),
	      .p3cntr_width(32'd1),
	      .guarded(1'd1)) inst1_ff_dest_addr(.RST(RST_N),
						 .CLK(CLK),
						 .D_IN(inst1_ff_dest_addr$D_IN),
						 .ENQ(inst1_ff_dest_addr$ENQ),
						 .DEQ(inst1_ff_dest_addr$DEQ),
						 .CLR(inst1_ff_dest_addr$CLR),
						 .D_OUT(inst1_ff_dest_addr$D_OUT),
						 .FULL_N(inst1_ff_dest_addr$FULL_N),
						 .EMPTY_N(inst1_ff_dest_addr$EMPTY_N));

  // submodule inst1_m_xactor_f_rd_addr
  FIFO2 #(.width(32'd52),
	  .guarded(1'd1)) inst1_m_xactor_f_rd_addr(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(inst1_m_xactor_f_rd_addr$D_IN),
						   .ENQ(inst1_m_xactor_f_rd_addr$ENQ),
						   .DEQ(inst1_m_xactor_f_rd_addr$DEQ),
						   .CLR(inst1_m_xactor_f_rd_addr$CLR),
						   .D_OUT(inst1_m_xactor_f_rd_addr$D_OUT),
						   .FULL_N(inst1_m_xactor_f_rd_addr$FULL_N),
						   .EMPTY_N(inst1_m_xactor_f_rd_addr$EMPTY_N));

  // submodule inst1_m_xactor_f_rd_data
  FIFO2 #(.width(32'd135),
	  .guarded(1'd1)) inst1_m_xactor_f_rd_data(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(inst1_m_xactor_f_rd_data$D_IN),
						   .ENQ(inst1_m_xactor_f_rd_data$ENQ),
						   .DEQ(inst1_m_xactor_f_rd_data$DEQ),
						   .CLR(inst1_m_xactor_f_rd_data$CLR),
						   .D_OUT(inst1_m_xactor_f_rd_data$D_OUT),
						   .FULL_N(inst1_m_xactor_f_rd_data$FULL_N),
						   .EMPTY_N(inst1_m_xactor_f_rd_data$EMPTY_N));

  // submodule inst1_m_xactor_f_wr_addr
  FIFO2 #(.width(32'd52),
	  .guarded(1'd1)) inst1_m_xactor_f_wr_addr(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(inst1_m_xactor_f_wr_addr$D_IN),
						   .ENQ(inst1_m_xactor_f_wr_addr$ENQ),
						   .DEQ(inst1_m_xactor_f_wr_addr$DEQ),
						   .CLR(inst1_m_xactor_f_wr_addr$CLR),
						   .D_OUT(inst1_m_xactor_f_wr_addr$D_OUT),
						   .FULL_N(),
						   .EMPTY_N(inst1_m_xactor_f_wr_addr$EMPTY_N));

  // submodule inst1_m_xactor_f_wr_data
  FIFO2 #(.width(32'd149),
	  .guarded(1'd1)) inst1_m_xactor_f_wr_data(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(inst1_m_xactor_f_wr_data$D_IN),
						   .ENQ(inst1_m_xactor_f_wr_data$ENQ),
						   .DEQ(inst1_m_xactor_f_wr_data$DEQ),
						   .CLR(inst1_m_xactor_f_wr_data$CLR),
						   .D_OUT(inst1_m_xactor_f_wr_data$D_OUT),
						   .FULL_N(),
						   .EMPTY_N(inst1_m_xactor_f_wr_data$EMPTY_N));

  // submodule inst1_m_xactor_f_wr_resp
  FIFO2 #(.width(32'd6), .guarded(1'd1)) inst1_m_xactor_f_wr_resp(.RST(RST_N),
								  .CLK(CLK),
								  .D_IN(inst1_m_xactor_f_wr_resp$D_IN),
								  .ENQ(inst1_m_xactor_f_wr_resp$ENQ),
								  .DEQ(inst1_m_xactor_f_wr_resp$DEQ),
								  .CLR(inst1_m_xactor_f_wr_resp$CLR),
								  .D_OUT(),
								  .FULL_N(inst1_m_xactor_f_wr_resp$FULL_N),
								  .EMPTY_N());

  // rule RL_inst1_rl_start_dram_Read
  assign WILL_FIRE_RL_inst1_rl_start_dram_Read =
	     inst1_ff_dest_addr$FULL_N && inst1_m_xactor_f_rd_addr$FULL_N &&
	     inst1_rg_params[120] &&
	     inst1_rg_load_requests ;

  // rule RL_inst1_rl_start_write
  assign WILL_FIRE_RL_inst1_rl_start_write =
	     inst1_m_xactor_f_rd_data$EMPTY_N && inst1_ff_dest_addr$EMPTY_N &&
	     inst1_rg_params[120] &&
	     inst1_m_xactor_f_rd_data$D_OUT[3:0] == 4'd2 &&
	     inst1_m_xactor_f_rd_data$D_OUT[134:133] == 2'd0 ;

  // inputs to muxes for submodule ports
  assign MUX_inst1_rg_dram_addr$write_1__SEL_1 =
	     WILL_FIRE_RL_inst1_rl_start_dram_Read &&
	     (inst1_rg_x_cntr != 8'd0 || inst1_rg_y_cntr != 8'd0) ;
  assign MUX_inst1_rg_load_requests$write_1__SEL_1 =
	     WILL_FIRE_RL_inst1_rl_start_dram_Read &&
	     inst1_rg_x_cntr == 8'd0 &&
	     inst1_rg_y_cntr == 8'd0 ;
  assign MUX_inst1_rg_sram_addr$write_1__SEL_1 =
	     WILL_FIRE_RL_inst1_rl_start_dram_Read &&
	     (inst1_rg_sram_addr >= 26'h1000000 &&
	      inst1_rg_sram_addr <= 26'h1FFFFFF ||
	      inst1_rg_sram_addr >= 26'h2000000 &&
	      inst1_rg_sram_addr <= 26'h2FFFFFF ||
	      inst1_rg_sram_addr >= 26'h3000000) ;
  assign MUX_inst1_rg_x_cntr$write_1__SEL_1 =
	     WILL_FIRE_RL_inst1_rl_start_dram_Read &&
	     inst1_rg_x_cntr != 8'd0 &&
	     inst1_rg_y_cntr == 8'd0 ;
  assign MUX_inst1_rg_burst_addr$write_1__VAL_2 =
	     { !inst1_m_xactor_f_rd_data$D_OUT[4],
	       _theResult____h2090 + y__h2232 } ;
  assign MUX_inst1_rg_dram_addr$write_1__VAL_1 =
	     (inst1_rg_y_cntr == 8'd0) ? x__h1512 : x__h1647 ;
  assign MUX_inst1_rg_params$write_1__VAL_2 =
	     { 1'd1, subifc_put_loadparams_put } ;
  assign MUX_inst1_rg_sram_addr$write_1__VAL_1 = inst1_rg_sram_addr + 26'd32 ;
  assign MUX_inst1_rg_x_cntr$write_1__VAL_1 = inst1_rg_x_cntr - 8'd1 ;
  assign MUX_inst1_rg_x_cntr$write_1__VAL_2 =
	     subifc_put_loadparams_put[61:54] - 8'd1 ;
  assign MUX_inst1_rg_y_cntr$write_1__VAL_1 =
	     (inst1_rg_y_cntr == 8'd0) ? x__h1399 : x__h1613 ;
  assign MUX_inst1_rg_y_cntr$write_1__VAL_2 =
	     subifc_put_loadparams_put[53:46] - 8'd1 ;
  assign MUX_inst1_rg_z_cntr$write_1__VAL_2 =
	     inst1_m_xactor_f_rd_data$D_OUT[4] ?
	       inst1_rg_params[45:38] :
	       x__h2129 ;

  // inlined wires
  assign inst1_wr_buffer_req$whas =
	     WILL_FIRE_RL_inst1_rl_start_write &&
	     (_theResult____h2090 >= 26'h1000000 &&
	      _theResult____h2090 <= 26'h1FFFFFF ||
	      _theResult____h2090 >= 26'h2000000 &&
	      _theResult____h2090 <= 26'h2FFFFFF ||
	      _theResult____h2090 >= 26'h3000000) ;

  // register inst1_rg_burst
  assign inst1_rg_burst$D_IN = 1'b0 ;
  assign inst1_rg_burst$EN = 1'b0 ;

  // register inst1_rg_burst_addr
  assign inst1_rg_burst_addr$D_IN =
	     EN_subifc_put_loadparams_put ?
	       27'd44739242 :
	       MUX_inst1_rg_burst_addr$write_1__VAL_2 ;
  assign inst1_rg_burst_addr$EN =
	     EN_subifc_put_loadparams_put ||
	     WILL_FIRE_RL_inst1_rl_start_write ;

  // register inst1_rg_burst_len
  assign inst1_rg_burst_len$D_IN =
	     (lv_shift__h3295 < 11'd16) ? 8'd0 : shift_op__h3296 - 8'd1 ;
  assign inst1_rg_burst_len$EN = EN_subifc_put_loadparams_put ;

  // register inst1_rg_dram_addr
  assign inst1_rg_dram_addr$D_IN =
	     MUX_inst1_rg_dram_addr$write_1__SEL_1 ?
	       MUX_inst1_rg_dram_addr$write_1__VAL_1 :
	       subifc_put_loadparams_put[119:88] ;
  assign inst1_rg_dram_addr$EN =
	     WILL_FIRE_RL_inst1_rl_start_dram_Read &&
	     (inst1_rg_x_cntr != 8'd0 || inst1_rg_y_cntr != 8'd0) ||
	     EN_subifc_put_loadparams_put ;

  // register inst1_rg_finish_load
  assign inst1_rg_finish_load$D_IN = !EN_subifc_put_loadparams_put ;
  assign inst1_rg_finish_load$EN =
	     EN_subifc_put_loadparams_put ||
	     inst1_rg_params[120] && !inst1_ff_dest_addr$EMPTY_N &&
	     !inst1_rg_load_requests &&
	     !inst1_rg_finish_load ;

  // register inst1_rg_interrupt
  assign inst1_rg_interrupt$D_IN = 1'd1 ;
  assign inst1_rg_interrupt$EN =
	     inst1_m_xactor_f_rd_data$EMPTY_N &&
	     inst1_m_xactor_f_rd_data$D_OUT[3:0] == 4'd2 &&
	     inst1_m_xactor_f_rd_data$D_OUT[134:133] == 2'd2 ;

  // register inst1_rg_load_requests
  assign inst1_rg_load_requests$D_IN =
	     !MUX_inst1_rg_load_requests$write_1__SEL_1 ;
  assign inst1_rg_load_requests$EN =
	     WILL_FIRE_RL_inst1_rl_start_dram_Read &&
	     inst1_rg_x_cntr == 8'd0 &&
	     inst1_rg_y_cntr == 8'd0 ||
	     EN_subifc_put_loadparams_put ;

  // register inst1_rg_params
  assign inst1_rg_params$D_IN =
	     EN_subifc_send_loadfinish_get ?
	       121'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA :
	       MUX_inst1_rg_params$write_1__VAL_2 ;
  assign inst1_rg_params$EN =
	     EN_subifc_send_loadfinish_get || EN_subifc_put_loadparams_put ;

  // register inst1_rg_sram_addr
  assign inst1_rg_sram_addr$D_IN =
	     MUX_inst1_rg_sram_addr$write_1__SEL_1 ?
	       MUX_inst1_rg_sram_addr$write_1__VAL_1 :
	       subifc_put_loadparams_put[87:62] ;
  assign inst1_rg_sram_addr$EN =
	     WILL_FIRE_RL_inst1_rl_start_dram_Read &&
	     (inst1_rg_sram_addr >= 26'h1000000 &&
	      inst1_rg_sram_addr <= 26'h1FFFFFF ||
	      inst1_rg_sram_addr >= 26'h2000000 &&
	      inst1_rg_sram_addr <= 26'h2FFFFFF ||
	      inst1_rg_sram_addr >= 26'h3000000) ||
	     EN_subifc_put_loadparams_put ;

  // register inst1_rg_x_cntr
  assign inst1_rg_x_cntr$D_IN =
	     MUX_inst1_rg_x_cntr$write_1__SEL_1 ?
	       MUX_inst1_rg_x_cntr$write_1__VAL_1 :
	       MUX_inst1_rg_x_cntr$write_1__VAL_2 ;
  assign inst1_rg_x_cntr$EN =
	     WILL_FIRE_RL_inst1_rl_start_dram_Read &&
	     inst1_rg_x_cntr != 8'd0 &&
	     inst1_rg_y_cntr == 8'd0 ||
	     EN_subifc_put_loadparams_put ;

  // register inst1_rg_xyz_size
  assign inst1_rg_xyz_size$D_IN = 26'h0 ;
  assign inst1_rg_xyz_size$EN = 1'b0 ;

  // register inst1_rg_y_cntr
  assign inst1_rg_y_cntr$D_IN =
	     MUX_inst1_rg_dram_addr$write_1__SEL_1 ?
	       MUX_inst1_rg_y_cntr$write_1__VAL_1 :
	       MUX_inst1_rg_y_cntr$write_1__VAL_2 ;
  assign inst1_rg_y_cntr$EN =
	     WILL_FIRE_RL_inst1_rl_start_dram_Read &&
	     (inst1_rg_x_cntr != 8'd0 || inst1_rg_y_cntr != 8'd0) ||
	     EN_subifc_put_loadparams_put ;

  // register inst1_rg_z_cntr
  assign inst1_rg_z_cntr$D_IN =
	     EN_subifc_put_loadparams_put ?
	       subifc_put_loadparams_put[45:38] :
	       MUX_inst1_rg_z_cntr$write_1__VAL_2 ;
  assign inst1_rg_z_cntr$EN =
	     EN_subifc_put_loadparams_put ||
	     WILL_FIRE_RL_inst1_rl_start_write ;

  // register inst1_rg_zy_size
  assign inst1_rg_zy_size$D_IN = 26'h0 ;
  assign inst1_rg_zy_size$EN = 1'b0 ;

  // submodule inst1_ff_dest_addr
  assign inst1_ff_dest_addr$D_IN = inst1_rg_sram_addr ;
  assign inst1_ff_dest_addr$ENQ = WILL_FIRE_RL_inst1_rl_start_dram_Read ;
  assign inst1_ff_dest_addr$DEQ =
	     WILL_FIRE_RL_inst1_rl_start_write &&
	     inst1_m_xactor_f_rd_data$D_OUT[4] ;
  assign inst1_ff_dest_addr$CLR = 1'b0 ;

  // submodule inst1_m_xactor_f_rd_addr
  assign inst1_m_xactor_f_rd_addr$D_IN =
	     { inst1_rg_dram_addr, 6'h14, inst1_rg_burst_len, 6'd18 } ;
  assign inst1_m_xactor_f_rd_addr$ENQ =
	     WILL_FIRE_RL_inst1_rl_start_dram_Read ;
  assign inst1_m_xactor_f_rd_addr$DEQ =
	     inst1_m_xactor_f_rd_addr$EMPTY_N && master_ARREADY ;
  assign inst1_m_xactor_f_rd_addr$CLR = 1'b0 ;

  // submodule inst1_m_xactor_f_rd_data
  assign inst1_m_xactor_f_rd_data$D_IN =
	     { master_RRESP, master_RDATA, master_RLAST, master_RID } ;
  assign inst1_m_xactor_f_rd_data$ENQ =
	     master_RVALID && inst1_m_xactor_f_rd_data$FULL_N ;
  assign inst1_m_xactor_f_rd_data$DEQ =
	     inst1_m_xactor_f_rd_data$EMPTY_N &&
	     inst1_m_xactor_f_rd_data$D_OUT[3:0] == 4'd2 &&
	     inst1_m_xactor_f_rd_data$D_OUT[134:133] == 2'd2 ||
	     WILL_FIRE_RL_inst1_rl_start_write ;
  assign inst1_m_xactor_f_rd_data$CLR = 1'b0 ;

  // submodule inst1_m_xactor_f_wr_addr
  assign inst1_m_xactor_f_wr_addr$D_IN = 52'h0 ;
  assign inst1_m_xactor_f_wr_addr$ENQ = 1'b0 ;
  assign inst1_m_xactor_f_wr_addr$DEQ =
	     inst1_m_xactor_f_wr_addr$EMPTY_N && master_AWREADY ;
  assign inst1_m_xactor_f_wr_addr$CLR = 1'b0 ;

  // submodule inst1_m_xactor_f_wr_data
  assign inst1_m_xactor_f_wr_data$D_IN = 149'h0 ;
  assign inst1_m_xactor_f_wr_data$ENQ = 1'b0 ;
  assign inst1_m_xactor_f_wr_data$DEQ =
	     inst1_m_xactor_f_wr_data$EMPTY_N && master_WREADY ;
  assign inst1_m_xactor_f_wr_data$CLR = 1'b0 ;

  // submodule inst1_m_xactor_f_wr_resp
  assign inst1_m_xactor_f_wr_resp$D_IN = { master_BRESP, master_BID } ;
  assign inst1_m_xactor_f_wr_resp$ENQ =
	     master_BVALID && inst1_m_xactor_f_wr_resp$FULL_N ;
  assign inst1_m_xactor_f_wr_resp$DEQ = 1'b0 ;
  assign inst1_m_xactor_f_wr_resp$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_NOT_IF_inst1_rg_burst_addr_5_BIT_26_6_THEN__ETC___d104 =
	     (_theResult____h2090 >= 26'h1000000 &&
	      _theResult____h2090 <= 26'h1FFFFFF ||
	      _theResult____h2090 >= 26'h2000000 &&
	      _theResult____h2090 <= 26'h2FFFFFF) ?
	       x__h2632[5:0] :
	       x__h2712[5:0] ;
  assign IF_inst1_rg_params_BIT_20_4_THEN_0_ELSE_2___d25 =
	     inst1_rg_params[20] ? 32'd0 : 32'd2 ;
  assign _theResult____h2090 =
	     inst1_rg_burst_addr[26] ?
	       inst1_rg_burst_addr[25:0] :
	       inst1_ff_dest_addr$D_OUT ;
  assign lv_shift__h3295 =
	     { 3'd0, subifc_put_loadparams_put[45:38] } <<
	     (subifc_put_loadparams_put[20] ? 32'd0 : 32'd2) ;
  assign shift_op__h3296 = { 1'd0, lv_shift__h3295[10:4] } ;
  assign x__h1399 = inst1_rg_params[53:46] - 8'd1 ;
  assign x__h1512 = inst1_rg_dram_addr + y__h1547 ;
  assign x__h1560 = { 24'd0, inst1_rg_params[29:22] } ;
  assign x__h1613 = inst1_rg_y_cntr - 8'd1 ;
  assign x__h1647 = inst1_rg_dram_addr + y__h1667 ;
  assign x__h1668 = { 24'd0, inst1_rg_params[37:30] } ;
  assign x__h2129 = inst1_rg_z_cntr - y__h2149 ;
  assign x__h2632 = (inst1_rg_z_cntr <= 8'd16) ? inst1_rg_z_cntr : 8'd16 ;
  assign x__h2712 = (inst1_rg_z_cntr <= 8'd4) ? inst1_rg_z_cntr : 8'd4 ;
  assign y__h1547 =
	     x__h1560 << IF_inst1_rg_params_BIT_20_4_THEN_0_ELSE_2___d25 ;
  assign y__h1667 =
	     x__h1668 << IF_inst1_rg_params_BIT_20_4_THEN_0_ELSE_2___d25 ;
  assign y__h2149 = inst1_rg_params[20] ? 8'd16 : 8'd4 ;
  assign y__h2232 =
	     26'd16 >> IF_inst1_rg_params_BIT_20_4_THEN_0_ELSE_2___d25 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        inst1_rg_burst <= `BSV_ASSIGNMENT_DELAY 1'd0;
	inst1_rg_burst_addr <= `BSV_ASSIGNMENT_DELAY 27'd44739242;
	inst1_rg_burst_len <= `BSV_ASSIGNMENT_DELAY 8'd0;
	inst1_rg_dram_addr <= `BSV_ASSIGNMENT_DELAY 32'd0;
	inst1_rg_finish_load <= `BSV_ASSIGNMENT_DELAY 1'd1;
	inst1_rg_interrupt <= `BSV_ASSIGNMENT_DELAY 1'd0;
	inst1_rg_load_requests <= `BSV_ASSIGNMENT_DELAY 1'd0;
	inst1_rg_params <= `BSV_ASSIGNMENT_DELAY
	    121'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
	inst1_rg_sram_addr <= `BSV_ASSIGNMENT_DELAY 26'd0;
	inst1_rg_x_cntr <= `BSV_ASSIGNMENT_DELAY 8'd0;
	inst1_rg_xyz_size <= `BSV_ASSIGNMENT_DELAY 26'd0;
	inst1_rg_y_cntr <= `BSV_ASSIGNMENT_DELAY 8'd0;
	inst1_rg_z_cntr <= `BSV_ASSIGNMENT_DELAY 8'd0;
	inst1_rg_zy_size <= `BSV_ASSIGNMENT_DELAY 26'd0;
      end
    else
      begin
        if (inst1_rg_burst$EN)
	  inst1_rg_burst <= `BSV_ASSIGNMENT_DELAY inst1_rg_burst$D_IN;
	if (inst1_rg_burst_addr$EN)
	  inst1_rg_burst_addr <= `BSV_ASSIGNMENT_DELAY
	      inst1_rg_burst_addr$D_IN;
	if (inst1_rg_burst_len$EN)
	  inst1_rg_burst_len <= `BSV_ASSIGNMENT_DELAY inst1_rg_burst_len$D_IN;
	if (inst1_rg_dram_addr$EN)
	  inst1_rg_dram_addr <= `BSV_ASSIGNMENT_DELAY inst1_rg_dram_addr$D_IN;
	if (inst1_rg_finish_load$EN)
	  inst1_rg_finish_load <= `BSV_ASSIGNMENT_DELAY
	      inst1_rg_finish_load$D_IN;
	if (inst1_rg_interrupt$EN)
	  inst1_rg_interrupt <= `BSV_ASSIGNMENT_DELAY inst1_rg_interrupt$D_IN;
	if (inst1_rg_load_requests$EN)
	  inst1_rg_load_requests <= `BSV_ASSIGNMENT_DELAY
	      inst1_rg_load_requests$D_IN;
	if (inst1_rg_params$EN)
	  inst1_rg_params <= `BSV_ASSIGNMENT_DELAY inst1_rg_params$D_IN;
	if (inst1_rg_sram_addr$EN)
	  inst1_rg_sram_addr <= `BSV_ASSIGNMENT_DELAY inst1_rg_sram_addr$D_IN;
	if (inst1_rg_x_cntr$EN)
	  inst1_rg_x_cntr <= `BSV_ASSIGNMENT_DELAY inst1_rg_x_cntr$D_IN;
	if (inst1_rg_xyz_size$EN)
	  inst1_rg_xyz_size <= `BSV_ASSIGNMENT_DELAY inst1_rg_xyz_size$D_IN;
	if (inst1_rg_y_cntr$EN)
	  inst1_rg_y_cntr <= `BSV_ASSIGNMENT_DELAY inst1_rg_y_cntr$D_IN;
	if (inst1_rg_z_cntr$EN)
	  inst1_rg_z_cntr <= `BSV_ASSIGNMENT_DELAY inst1_rg_z_cntr$D_IN;
	if (inst1_rg_zy_size$EN)
	  inst1_rg_zy_size <= `BSV_ASSIGNMENT_DELAY inst1_rg_zy_size$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    inst1_rg_burst = 1'h0;
    inst1_rg_burst_addr = 27'h2AAAAAA;
    inst1_rg_burst_len = 8'hAA;
    inst1_rg_dram_addr = 32'hAAAAAAAA;
    inst1_rg_finish_load = 1'h0;
    inst1_rg_interrupt = 1'h0;
    inst1_rg_load_requests = 1'h0;
    inst1_rg_params = 121'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    inst1_rg_sram_addr = 26'h2AAAAAA;
    inst1_rg_x_cntr = 8'hAA;
    inst1_rg_xyz_size = 26'h2AAAAAA;
    inst1_rg_y_cntr = 8'hAA;
    inst1_rg_z_cntr = 8'hAA;
    inst1_rg_zy_size = 26'h2AAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkload

